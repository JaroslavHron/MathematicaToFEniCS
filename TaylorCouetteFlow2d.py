# This file was generated by MathematicaToFEniCS
from MathematicaToFEniCS import *
from meshTaylorCouette2d import *


# Define few useful expressions
ptx = Expression(("x[0]","x[1]","x[2]"))


# Initialize function spaces and functions
funSpaceCG2 = FunctionSpace(meshTaylorCouette2d, 'CG', 2, constrained_domain=PeriodicBoundary())
funSpaceCG1 = FunctionSpace(meshTaylorCouette2d, 'CG', 1, constrained_domain=PeriodicBoundary())
totalSpace = MixedFunctionSpace([funSpaceCG2,funSpaceCG2,funSpaceCG2,funSpaceCG1])
w = Function( totalSpace )
vr,vt,vz,p = split(w)
tvr,tvt,tvz,tp = TestFunctions(totalSpace)


# Define weak form
F1 = (ptx[0]*((tvr*(-p + vr/(500.*ptx[0])))/ptx[0] + (Derivative(0,1)(tvt)*Derivative(0,1)(vt))/1000. + Derivative(0,1)(tvz)*(-p + Derivative(0,1)(vz)/500.) + Derivative(1,0)(tvr)*(-p + Derivative(1,0)(vr)/500.) + tvr*(-(Power(vt,2)/ptx[0]) + vz*Derivative(0,1)(vr) + vr*Derivative(1,0)(vr)) - (tvt*(-(vt/ptx[0]) + Derivative(1,0)(vt)))/(1000.*ptx[0]) + (Derivative(1,0)(tvt)*(-(vt/ptx[0]) + Derivative(1,0)(vt)))/1000. + tvt*((vr*vt)/ptx[0] + vz*Derivative(0,1)(vt) + vr*Derivative(1,0)(vt)) + (Derivative(0,1)(tvr)*(Derivative(0,1)(vr) + Derivative(1,0)(vz)))/1000. + (Derivative(1,0)(tvz)*(Derivative(0,1)(vr) + Derivative(1,0)(vz)))/1000. + tvz*(vz*Derivative(0,1)(vz) + vr*Derivative(1,0)(vz))))*dx 
F2 = (vz*Derivative(0,1)(tp) + vr*Derivative(1,0)(tp))*dx
F = F1+F2


# Define boundary conditions
bc_vr_1 = DirichletBC(totalSpace.sub(0), Constant(0), boundary_parts, 1)
bc_vr_2 = DirichletBC(totalSpace.sub(0), Constant(0), boundary_parts, 2)
bc_vt_1 = DirichletBC(totalSpace.sub(1), Constant(1), boundary_parts, 1)
bc_vt_2 = DirichletBC(totalSpace.sub(1), Constant(0), boundary_parts, 2)
bc_vz_1 = DirichletBC(totalSpace.sub(2), Constant(0), boundary_parts, 1)
bc_vz_2 = DirichletBC(totalSpace.sub(2), Constant(0), boundary_parts, 2)
bc = [bc_vr_1,bc_vr_2,bc_vt_1,bc_vt_2,bc_vz_1,bc_vz_2]


# Initialize solver
J = derivative(F,w)
problem = NonlinearVariationalProblem(F,w,bc,J)
solver = NonlinearVariationalSolver(problem)

prm = solver.parameters
prm['newton_solver']['absolute_tolerance'] = 1E-8
prm['newton_solver']['relative_tolerance'] = 1E-7
prm['newton_solver']['maximum_iterations'] = 10
prm['newton_solver']['relaxation_parameter'] = 1.0


# Solve and plot
solver.solve()

plot(vr, title="vr")
plot(vt, title="vt")
plot(vz, title="vz")
plot(p, title="p")

interactive()


