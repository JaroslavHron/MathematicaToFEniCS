# This file was generated by MathematicaToFEniCS
from MathematicaToFEniCS import *
from meshBox import *


# Define few useful expressions
ptx = Expression(("x[0]","x[1]","x[2]"))


#parameters['form_compiler']['optimize'] = True
#parameters['form_compiler']['quadrature_degree'] = 4

# Initialize function spaces and functions
funSpaceLagrange2 = FunctionSpace(meshBox, 'Lagrange', 2)
funSpaceLagrange1 = FunctionSpace(meshBox, 'Lagrange', 1)
totalSpace = MixedFunctionSpace([funSpaceLagrange2,funSpaceLagrange2,funSpaceLagrange1])
w = Function( totalSpace )
u,v,p = split(w)
tu,tv,tp = TestFunctions(totalSpace)


# Define boundary measure on Neumann part of boundary
dsN = Measure("ds", subdomain_id=2, subdomain_data=boundary_parts)

FORCE = Constant(1.)
G = Constant(1.0)

# Define weak form
F1 = (-((-(p*((1 + Derivative(0,1)(v))*Derivative(1,0)(tu) - Derivative(0,1)(u)*Derivative(1,0)(tv) + Derivative(0,1)(tv)*(1 + Derivative(1,0)(u)) - Derivative(0,1)(tu)*Derivative(1,0)(v))) + G*(Derivative(0,1)(u)*Derivative(1,0)(tv) + 2*Derivative(1,0)(tu)*Derivative(1,0)(u) + 2*Derivative(0,1)(v)*Derivative(1,0)(tu)*Derivative(1,0)(u) + Derivative(1,0)(tu)*Power(Derivative(1,0)(u),2) + Derivative(0,1)(v)*Derivative(1,0)(tu)*Power(Derivative(1,0)(u),2) - Derivative(0,1)(u)*Derivative(1,0)(tu)*Derivative(1,0)(v) + Derivative(1,0)(tv)*Derivative(1,0)(v) + Derivative(0,1)(v)*Derivative(1,0)(tv)*Derivative(1,0)(v) - Derivative(0,1)(u)*Derivative(1,0)(tu)*Derivative(1,0)(u)*Derivative(1,0)(v) + Derivative(1,0)(tv)*Derivative(1,0)(u)*Derivative(1,0)(v) + Derivative(0,1)(v)*Derivative(1,0)(tv)*Derivative(1,0)(u)*Derivative(1,0)(v) - Derivative(0,1)(u)*Derivative(1,0)(tv)*Power(Derivative(1,0)(v),2) + Derivative(0,1)(tu)*(Derivative(0,1)(u)*(1 + Derivative(0,1)(v))*(1 + Derivative(1,0)(u)) + Derivative(1,0)(v) - Power(Derivative(0,1)(u),2)*Derivative(1,0)(v)) + Derivative(0,1)(tv)*(Power(Derivative(0,1)(v),2)*(1 + Derivative(1,0)(u)) - Derivative(0,1)(u)*Derivative(1,0)(v) + Derivative(0,1)(v)*(2 + 2*Derivative(1,0)(u) - Derivative(0,1)(u)*Derivative(1,0)(v)))))/(1 + Derivative(1,0)(u) + Derivative(0,1)(v)*(1 + Derivative(1,0)(u)) - Derivative(0,1)(u)*Derivative(1,0)(v))))*dx
F2 = (tp*(Derivative(0,1)(v) + Derivative(1,0)(u) + Derivative(0,1)(v)*Derivative(1,0)(u) - Derivative(0,1)(u)*Derivative(1,0)(v)))*dx
F3 = (0. + FORCE*tu)*dsN
F = F1+F2+F3


# Define boundary conditions
bc_u_1 = DirichletBC(totalSpace.sub(0), Constant(0), boundary_parts, 1)
bc_v_3 = DirichletBC(totalSpace.sub(1), Constant(0), boundary_parts, 3)
bc = [bc_u_1,bc_v_3]


# Initialize solver
J = derivative(F,w)
problem = NonlinearVariationalProblem(F,w,bc,J)
solver = NonlinearVariationalSolver(problem)

prm = solver.parameters
prm['newton_solver']['absolute_tolerance'] = 1E-8
prm['newton_solver']['relative_tolerance'] = 1E-7
prm['newton_solver']['maximum_iterations'] = 10
prm['newton_solver']['relaxation_parameter'] = 1.0



# Solve and plot
solver.solve()

print u((1.0,0.0))

e1 = Constant((1,0))
e2 = Constant((0,1))
plot(u, title="u")
plot(v, title="v")
plot(e1*u+e2*v )
plot(p, title="p")

interactive()


